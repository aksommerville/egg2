/* SongChannel.js
 * Single live channel of an EAU song.
 */
 
import { FREQUENCY_BY_NOTEID, WAVE_SIZE_SAMPLES, EauDecoder, Envelope } from "./songBits.js";
 
export class SongChannel {

  /* (trim) in 0..1, (pan) in -1..1.
   * (payload) and (post) are Uint8Array.
   * (tempo) is s/qnote. NB not ms.
   */
  constructor(chid, trim, pan, mode, payload, post, tempo) {
    console.log(`SongChannel.constructor`, { chid, trim, pan, mode, payload, post });
    this.chid = chid;
    this.trim = trim;
    this.pan = pan;
    this.mode = mode;
    this.payload = payload;
    this.post = post;
    this.tempo = tempo;
    this.ctx = null;
    this.nodes = []; // All live nodes.
    this.lastNode = null; // Usually trim or pan, the one connected to the context.
    this.postStart = null; // Start of post, or trim, the one voices should connect to.
    this.terminables = []; // { node, time }
    switch (this.mode) {
      case 1: this.drumDecode(this.payload); break;
      case 2: this.fmDecode(this.payload); break;
      case 3: this.subDecode(this.payload); break;
      default: this.neuter(); break;
    }
  }
  
  // Decoding payload should call this if we determine that the channel won't produce any output.
  neuter() {
    this.mode = 0;
    this.trim = 0;
    this.post = [];
  }
  
  play(ctx) {
    if (this.ctx) this.stop();
    this.ctx = ctx;
    if (!this.mode) return;
    
    switch (this.mode) {
      case 1: this.drumStart(); break;
      case 2: this.fmStart(); break;
      case 3: this.subStart(); break;
    }
    
    const trimNode = new GainNode(this.ctx, { gain: this.trim });
    this.nodes.push(trimNode);
    this.lastNode = trimNode;
    
    this.postStart = this.preparePost(this.post, trimNode);
    if (!this.postStart) this.postStart = trimNode;
    
    let panNode = null;
    if (this.pan) {
      panNode = new StereoPannerNode(this.ctx, { pan: this.pan });
      this.nodes.push(panNode);
      this.lastNode = panNode;
      trimNode.connect(panNode);
    }
    
    this.lastNode.connect(this.ctx.destination);
  }
  
  stop() {
    this.terminables = [];
    for (const node of this.nodes) {
      node.stop?.();
      node.disconnect?.();
    }
    this.nodes = [];
    this.lastNode?.disconnect();
    this.lastNode = null;
    this.postStart = null;
    this.ctx = null;
  }
  
  /* True if all voices have stopped playing.
   * Owner should poll this after it's done delivering events.
   * We're not considering tails generated by the post, eg Delay steps.
   */
  isFinished() {
    if (!this.ctx) return true;
    if (this.terminables.length) return false;
    return true;
  }
  
  update() {
    const now = this.ctx.currentTime;
    for (let i=this.terminables.length; i-->0; ) { // TODO This is a lot of churn. Maybe use a timeout instead.
      const { node, time } = this.terminables[i];
      if (time > now) continue;
      this.terminables.splice(i, 1);
      node.stop?.();
      node.disconnect?.();
      const p = this.nodes.indexOf(node);
      if (p >= 0) this.nodes.splice(p, 1);
    }
  }
  
  /* (noteid) in 0..127.
   * (velocity) in 0..1.
   * (when) in context seconds, presumably in the future.
   * (dur) in seconds. (requested time from start to release, then one expects a tail).
   */
  note(noteid, velocity, when, dur) {
    switch (this.mode) {
      case 1: this.drumNote(noteid, velocity, when, dur); break;
      case 2: this.fmNote(noteid, velocity, when, dur); break;
      case 3: this.subNote(noteid, velocity, when, dur); break;
    }
  }
  
  /* (v) in -1..1.
   * (when in context seconds.
   */
  wheel(v, when) {
    switch (this.mode) { // Only FM channels use the wheel.
      case 2: this.fmWheel(v, when); break;
    }
  }
  
  /* DRUM
   *******************************************************************************/
   
  drumDecode(src) {
    console.log(`TODO SongChannel.drumDecode`, src);
    this.neuter();
  }
  
  drumStart() {
  }
   
  drumNote(noteid, velocity, when, dur) {
    console.log(`TODO SongChannel.drumNote ${noteid} ${velocity.toFixed(3)} ${when.toFixed(3)} ${dur.toFixed(3)}`);
  }
  
  /* FM
   *****************************************************************************/
   
  fmDecode(src) {
    console.log(`TODO SongChannel.fmDecode`, src);
    const decoder = new EauDecoder(src);
    if (!(this.levelEnv = decoder.env())) return this.neuter();
    
    this.wave = decoder.wave();
    
    this.pitchEnv = decoder.env(true);
    if (this.pitchEnv.flags || this.pitchEnv.points.length) {
      if (!(this.pitchEnv.flags & 0x02)) {
        this.pitchEnv.initlo = this.pitchEnv.inithi = 0x8000;
      }
      this.pitchEnv.bias(0x8000);
    }
    
    this.wheelRange = decoder.u16();
    this.modRate = decoder.u8_8();
    this.modRange = decoder.u8_8();
    if (this.modRate && this.modRange) {
      if (!(this.rangeEnv = decoder.env())) this.rangeEnv = Envelope.constant(1);
      this.rangeEnv.scale(this.modRange);
      this.rangeLfoRate = decoder.u8_8();
      this.rangeLfoDepth = decoder.u0_8();
    } else {
      this.modRate = 0;
    }
    console.log(`...fmDecode`, {
      levelEnv: this.levelEnv,
      wave: this.wave,
      pitchEnv: this.pitchEnv,
      wheelRange: this.wheelRange,
      modRate: this.modRate,
      modRange: this.modRange,
      rangeEnv: this.rangeEnv,
      rangeLfoRate: this.rangeLfoRate,
      rangeLfoDepth: this.rangeLfoDepth,
    });
  }
  
  fmStart() {
    if (this.wave instanceof Float32Array) {
      const buffer = new AudioBuffer({
        length: this.wave.length,
        sampleRate: this.ctx.sampleRate,
      });
      buffer.copyToChannel(this.wave, 0);
      this.wave = buffer;
    }
  }
   
  fmNote(noteid, velocity, when, dur) {
    console.log(`TODO SongChannel.fmNote ${noteid} ${velocity.toFixed(3)} ${when.toFixed(3)} ${dur.toFixed(3)}`);

    const frequency = FREQUENCY_BY_NOTEID[noteid];
    if (!frequency) return;
    //TODO Wheel
    
    const level = new GainNode(this.ctx, { gain: 0 });
    const termTime = this.levelEnv.apply(level.gain, velocity, when, dur) + 0.010;
    
    let osc;
    if (this.wave instanceof AudioBuffer) osc = this.oscillateImage(this.wave, frequency);
    else osc = this.oscillatePrimitive(this.wave, frequency);
    
    //TODO pitchEnv
    
    if (this.modRate) {
      const modulator = new OscillatorNode(this.ctx, {
        frequency: frequency * this.modRate,
        type: "sine",
      });
      modulator.start(when);
      const modgain = new GainNode(this.ctx, { gain: frequency });
      this.rangeEnv.mltapply(modgain.gain, frequency, velocity, when, dur);
      modulator.connect(modgain);
      modgain.connect(osc.frequency || osc.detune);//TODO (osc.detune) exists for AudioBufferSourceNode, but we're scaled wrong for it
      this.nodes.push(modgain);
      this.nodes.push(modulator);
      this.terminables.push({ node: modgain, time: termTime });
      this.terminables.push({ node: modulator, time: termTime });
    }
    
    osc.start(when);
    osc.connect(level);
    level.connect(this.postStart);
    this.nodes.push(osc);
    this.nodes.push(level);
    this.terminables.push({ node: osc, time: termTime });
    this.terminables.push({ node: level, time: termTime });
  }
  
  oscillateImage(src, frequency) {
    const node = new AudioBufferSourceNode(this.ctx, {
      buffer: this.wave,
      loop: true,
      loopEnd: 999,
      playbackRate: (frequency * WAVE_SIZE_SAMPLES) / this.ctx.sampleRate,
    });
    return node;
  }
  
  oscillatePrimitive(type, frequency) {
    return new OscillatorNode(this.ctx, { type, frequency });
  }
   
  fmWheel(v, when) {
    console.log(`SongChannel.fmWheel chid=${this.chid} v=${v} when=${when}`);//TODO
  }
   
  /* SUB
   ********************************************************************************/
   
  subDecode(src) {
    console.log(`TODO SongChannel.subDecode`, src);
    const decoder = new EauDecoder(src);
    if (!(this.levelEnv = decoder.env())) return this.neuter();
    this.widthlo = decoder.u16();
    this.widthhi = decoder.u16();
    this.stagec = decoder.u8();
    this.gain = decoder.u8_8();
    if (!this.stagec || !this.gain) return this.neuter();
  }
  
  subStart() {
  }
   
  subNote(noteid, velocity, when, dur) {
    console.log(`TODO SongChannel.subNote ${noteid} ${velocity.toFixed(3)} ${when.toFixed(3)} ${dur.toFixed(3)}`);
  }
   
  /* Post
   *******************************************************************************/
  
  /* (src) is Uint8Array. Returns AudioNode for the post's head, or null if none.
   * (dst) is an AudioNode to connect the tail to.
   * (this.ctx) must exist.
   */
  preparePost(src, dst) {
    this.postHead = null;
    this.postTail = null;
    let srcp=0;
    while (srcp < src.length) {
      const id = src[srcp++];
      const len = src[srcp++];
      if (srcp > src.length - len) break;
      const payload = new Uint8Array(src.buffer, src.byteOffset + srcp, len);
      srcp += len;
      switch (id) {
        case 1: this.addPostGain(payload); break;
        case 2: this.addPostDelay(payload); break;
        case 3: this.addPostLopass(payload); break;
        case 4: this.addPostHipass(payload); break;
        case 5: this.addPostBpass(payload); break;
        case 6: this.addPostNotch(payload); break;
        case 7: this.addPostWaveshaper(payload); break;
        case 8: this.addPostTremolo(payload); break;
      }
    }
    let result = null;
    if (this.postHead && this.postTail) {
      result = this.postHead;
      this.postTail.connect(dst);
    }
    delete this.postHead;
    delete this.postTail;
    return result;
  }
  
  /* The "addPost" functions must take input from (this.postTail), and replace (this.postTail) with their own tail.
   * If (this.postHead) is unset, they must put their own head there.
   * If (this.postTail) is unset, don't connect your input.
   * (postHead) and (postTail) are both null or neither null.
   * Add all created nodes to (this.nodes).
   * Since that's a little complicated, steps that wrap up in a single node can create that node as an orphan and pass to addSinglePost().
   */
   
  addSinglePost(node) {
    if (!node) return;
    this.nodes.push(node);
    if (this.postHead) {
      this.postTail.connect(node);
    } else {
      this.postHead = node;
    }
    this.postTail = node;
  }
  
  addPostGain(src) {
    // Gain is hilarious: In the native synthesizer it's the easiest filter, but in WebAudio it's the trickiest. :P
    let node = null;
    if (src.length === 2) {
      // When (clip) unspecified, it's easy, and we're allowed to overflow.
      const gain = ((src[0] << 8) | src[1]) / 256;
      node = new GainNode(this.ctx, { gain });
    } else if (src.length >= 3) {
      // Gain + clip. Must be effected with a WaveShaperNode.
      // The output curve is a simple three-legged shelf: Flat line, diagonal thru zero, flat line.
      // The elbow where that diagonal meets the high shelf is the interesting bit, from which we can calculate the rest.
      const gain = ((src[0] << 8) | src[1]) / 256;
      const clip = src[2] / 255;
      if (!gain || !clip) {
        node = new GainNode(this.ctx, { gain: 0 });
      } else {
        const ctlx = clip / gain; // Elbow's horizontal position in the unit square. Vertical position is just (clip).
        // How many uniformly-spaced control points do we need, to put (ctlx) within some reasonable distance of a control point?
        // I can't think of a good way to answer that except iteratively.
        const limit = 50; // Arbitrary.
        const tolerance = 0.010; // Arbitrary.
        let ctlc = 1; // How many positive control points.
        for (; ctlc<limit; ctlc++) {
          const spacing = 1 / ctlc;
          let d = ctlx % spacing;
          if (d <= tolerance) break;
          if (d >= spacing - tolerance) break;
        }
        const elbowp = Math.min(1, Math.floor(ctlx * ctlc));
        const levelc = ctlc * 2 + 1;
        const curve = new Float32Array(levelc);
        let lop = levelc - 1;
        let hip = levelc + 1;
        for (let i=1; i<elbowp; i++, lop--, hip++) {
          const level = (i * clip) / elbowp;
          curve[hip] = level;
          curve[lop] = -level;
        }
        for (let i=elbowp; i<ctlc; i++, lop--, hip++) {
          curve[hip] = clip;
          curve[lop] = -clip;
        }
        node = new WaveShaperNode(this.ctx, { curve });
      }
    }
    this.addSinglePost(node);
  }
  
  addPostDelay(src) {
    if (src.length < 6) return;
    const period = (((src[0] << 8) | src[1]) / 256) * this.tempo;
    if (period < 0.001) return;
    const dry = src[2] / 255;
    const wet = src[3] / 255;
    const sto = src[4] / 255;
    const fbk = src[5] / 255;
    
    const intakeNode = new GainNode(this.ctx, { gain: 1 });
    const dryNode = new GainNode(this.ctx, { gain: dry });
    intakeNode.connect(dryNode);
    const storeNode = new GainNode(this.ctx, { gain: sto });
    intakeNode.connect(storeNode);
    const delayNode = new DelayNode(this.ctx, { delayTime: period });
    storeNode.connect(delayNode);
    const feedbackNode = new GainNode(this.ctx, { gain: fbk });
    delayNode.connect(feedbackNode);
    feedbackNode.connect(delayNode);
    const wetNode = new GainNode(this.ctx, { gain: wet });
    feedbackNode.connect(wetNode);
    const outputNode = new GainNode(this.ctx, { gain: 1 });
    dryNode.connect(outputNode);
    wetNode.connect(outputNode);
    
    if (this.postHead) {
      this.postTail.connect(intakeNode);
    } else {
      this.postHead = intakeNode;
    }
    this.postTail = outputNode;
    this.nodes.push(intakeNode);
    this.nodes.push(dryNode);
    this.nodes.push(storeNode);
    this.nodes.push(delayNode);
    this.nodes.push(feedbackNode);
    this.nodes.push(wetNode);
    this.nodes.push(outputNode);
  }
  
  addPostLopass(src) {
    if (src.length < 2) return;
    const frequency = (src[0] << 8) | src[1];
    this.addSinglePost(new BiquadFilterNode(this.ctx, {
      type: "lowpass",
      frequency,
      //TODO is it ok to omit Q?
    }));
  }
  
  addPostHipass(src) {
    if (src.length < 2) return;
    const frequency = (src[0] << 8) | src[1];
    this.addSinglePost(new BiquadFilterNode(this.ctx, {
      type: "highpass",
      frequency,
      //TODO is it ok to omit Q?
    }));
  }
  
  addPostBpass(src) {
    if (src.length < 4) return;
    const frequency = (src[0] << 8) | src[1];
    const width = (src[2] << 8) | src[3];
    this.addSinglePost(new BiquadFilterNode(this.ctx, {
      type: "bandpass",
      frequency,
      Q: frequency / width,
    }));
  }
  
  addPostNotch(src) {
    if (src.length < 4) return;
    const frequency = (src[0] << 8) | src[1];
    const width = (src[2] << 8) | src[3];
    this.addSinglePost(new BiquadFilterNode(this.ctx, {
      type: "notch",
      frequency,
      Q: frequency / width,
    }));
  }
  
  addPostWaveshaper(src) {
    const srclevelc = src.length >> 1;
    if (srclevelc < 1) return;
    // (src) only describes the positive portion of the curve. So the full curve's length is (srclevelc*2+1).
    const dstlevelc = srclevelc * 2 + 1;
    const curve = new Float32Array(dstlevelc);
    let lop = dstlevelc >> 1;
    curve[lop] = 0;
    let hip = lop + 1;
    lop--;
    for (let srcp=0; srcp<src.length; srcp+=2, lop--, hip++) {
      const level = ((src[srcp] << 8) | src[srcp+1]) / 65535.0;
      curve[hip] = level;
      curve[lop] = -level;
    }
    this.addSinglePost(new WaveShaperNode(this.ctx, { curve }));
  }
  
  addPostTremolo(src) {
    if (src.length < 4) return;
    const period = (((src[0] << 8) | src[1]) / 256) * this.tempo;
    if (period < 0.001) return;
    const depth = src[2] / 255;
    if (!depth) return;
    const phase = src[3] / 256;
    
    const gainNode = new GainNode(this.ctx, { gain: 1 });
    const osc = new OscillatorNode(this.ctx, { frequency: 1 / period });
    osc.start();//TODO Adjust start time to respect (phase).
    // We need attenuation and also a DC offset. There might be simpler ways to express that? But WaveShaperNode can do it generically.
    const adjust = new WaveShaperNode(this.ctx, { curve: new Float32Array([1 - depth, 1 - depth / 2, 1]) });
    osc.connect(adjust);
    adjust.connect(gainNode.gain);
    this.nodes.push(osc);
    this.nodes.push(adjust);
    this.addSinglePost(gainNode);
  }
}
